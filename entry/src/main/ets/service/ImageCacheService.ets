import http from '@ohos.net.http'
import fs from '@ohos.file.fs'
import { common } from '@kit.AbilityKit'
import PreferencesUtil from '../utils/PreferencesUtil'

/**
 * å›¾ç‰‡ç¼“å­˜æœåŠ¡ - å‚è€ƒ FaviconDownloader ç®€åŒ–å®ç°
 */
export class ImageCacheService {
  private static readonly TIMEOUT = 8000 // 8ç§’è¶…æ—¶
  private static readonly MAX_FILE_SIZE = 20 * 1024 * 1024 // 20MBæœ€å¤§æ–‡ä»¶å¤§å°ï¼ˆæ”¯æŒå¤§å‹GIFåŠ¨ç”»ï¼‰

  /** ç”Ÿæˆç®€æ˜“ hash æ–‡ä»¶å */
  private static hash(url: string): string {
    let hash = 0
    for (let i = 0; i < url.length; i++) {
      hash = (hash << 5) - hash + url.charCodeAt(i)
      hash |= 0 // 32 ä½
    }
    return Math.abs(hash).toString()
  }

  private static normalize(url: string): string {
    const idx = url.indexOf('?')
    return idx >= 0 ? url.substring(0, idx) : url
  }

  /**
   * ä¸‹è½½å¹¶ç¼“å­˜å›¾ç‰‡
   * @param url å›¾ç‰‡URL
   * @param articleId æ–‡ç« ID
   * @param context åº”ç”¨ä¸Šä¸‹æ–‡
   * @returns æœ¬åœ°æ–‡ä»¶è·¯å¾„æˆ–null
   */
  static async downloadAndCache(
    url: string,
    articleId: string,
    context: common.UIAbilityContext,
    force: boolean = false // true æ—¶å¿½ç•¥é¦–é€‰é¡¹ï¼Œå§‹ç»ˆå°è¯•ç¼“å­˜
  ): Promise<string | null> {
    try {
      // åˆ›å»ºç¼“å­˜ç›®å½•
      const cacheDir = `${context.cacheDir}/rss_images/${ImageCacheService.hash(articleId)}`
      if (!await ImageCacheService.ensureDirectoryExists(cacheDir)) {
        throw new Error('æ— æ³•åˆ›å»ºç¼“å­˜ç›®å½•')
      }

      // æ£€æŸ¥ç£ç›˜ç©ºé—´ï¼ˆç®€å•è¯Šæ–­ï¼‰
      try {
        const testFile = `${cacheDir}/.space_test`
        const testData = new ArrayBuffer(1024) // 1KBæµ‹è¯•æ•°æ®
        const file = await fs.open(testFile, fs.OpenMode.CREATE | fs.OpenMode.WRITE_ONLY)
        await fs.write(file.fd, testData)
        await fs.close(file.fd)
        await fs.unlink(testFile) // åˆ é™¤æµ‹è¯•æ–‡ä»¶
        // console.info('ImageCacheService', 'ç£ç›˜ç©ºé—´æ£€æŸ¥é€šè¿‡')
      } catch (spaceError) {
        console.error('ImageCacheService', 'ç£ç›˜ç©ºé—´æ£€æŸ¥å¤±è´¥:', spaceError)
        throw new Error('ç£ç›˜ç©ºé—´ä¸è¶³æˆ–å†™å…¥æƒé™å¼‚å¸¸')
      }

      // ç”Ÿæˆæ–‡ä»¶å
      const normalizedUrl = ImageCacheService.normalize(url)
      const fileName = ImageCacheService.hash(normalizedUrl)
      const filePath = `${cacheDir}/${fileName}`

      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
      try {
        const stat = await fs.stat(filePath)
        if (stat.isFile()) {
          // console.info('ImageCacheService', `âœ… ç¼“å­˜å‘½ä¸­ - URL: ${url}`)
          // console.info('ImageCacheService', `âœ… ç¼“å­˜æ–‡ä»¶: ${filePath} (å¤§å°: ${stat.size} bytes)`)
          return filePath
        }
      } catch (_) { /* æ–‡ä»¶ä¸å­˜åœ¨ï¼Œç»§ç»­ä¸‹è½½ */ }

      // console.info('ImageCacheService', `ğŸ”„ å¼€å§‹ä¸‹è½½å›¾ç‰‡ - URL: ${url}`)
      // console.info('ImageCacheService', `ğŸ”„ ç›®æ ‡è·¯å¾„: ${filePath}`)

      // ä¸‹è½½å›¾ç‰‡
      const imageData = await ImageCacheService.downloadImage(url)
      if (!imageData) {
        console.error('ImageCacheService', `âŒ ä¸‹è½½å¤±è´¥ - URL: ${url}`)
        return null
      }

      // ä¿å­˜åˆ°æœ¬åœ°ï¼ˆæ·»åŠ é‡è¯•æœºåˆ¶ï¼‰
      let savedSuccessfully = false
      let retryCount = 0
      const maxRetries = 3

      while (!savedSuccessfully && retryCount < maxRetries) {
        try {
          // console.info('ImageCacheService', `ğŸ’¾ å°è¯•ä¿å­˜æ–‡ä»¶ (ç¬¬${retryCount + 1}æ¬¡) - è·¯å¾„: ${filePath}`)
          
          const file = await fs.open(filePath, fs.OpenMode.CREATE | fs.OpenMode.WRITE_ONLY)
          await fs.write(file.fd, imageData)
          await fs.close(file.fd)
          
          // éªŒè¯æ–‡ä»¶ä¿å­˜
          const savedStat = await fs.stat(filePath)
          if (savedStat.size === imageData.byteLength) {
            // console.info('ImageCacheService', `âœ… å›¾ç‰‡ä¸‹è½½å¹¶ç¼“å­˜å®Œæˆ - URL: ${url}`)
            // console.info('ImageCacheService', `âœ… ç¼“å­˜æ–‡ä»¶: ${filePath} (å¤§å°: ${savedStat.size} bytes)`)
            savedSuccessfully = true
            return filePath
          } else {
            throw new Error(`æ–‡ä»¶å¤§å°ä¸åŒ¹é…: æœŸæœ› ${imageData.byteLength} bytes, å®é™… ${savedStat.size} bytes`)
          }
        } catch (saveError) {
          retryCount++
          console.warn('ImageCacheService', `ğŸ’¾ ä¿å­˜å¤±è´¥ (ç¬¬${retryCount}æ¬¡): ${saveError}`)
          
          if (retryCount < maxRetries) {
            // æ¸…ç†å¯èƒ½å­˜åœ¨çš„ä¸å®Œæ•´æ–‡ä»¶
            try {
              await fs.unlink(filePath)
            } catch (_) { /* å¿½ç•¥åˆ é™¤å¤±è´¥ */ }
            
            // ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•
            await new Promise<void>(resolve => setTimeout(resolve, 500 * retryCount))
          } else {
            throw new Error(saveError instanceof Error ? saveError.message : String(saveError))
          }
        }
      }

      throw new Error('æ–‡ä»¶ä¿å­˜å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°')
    } catch (error) {
      // æ”¹è¿›é”™è¯¯ä¿¡æ¯æ˜¾ç¤º
      let errorMessage = 'Unknown error'
      if (error instanceof Error) {
        errorMessage = error.message
      } else if (typeof error === 'string') {
        errorMessage = error
      } else {
        errorMessage = JSON.stringify(error)
      }
      console.error('ImageCacheService', `âŒ ç¼“å­˜å›¾ç‰‡å¤±è´¥ - URL: ${url}, é”™è¯¯: ${errorMessage}`)
      return null
    }
  }

  /**
   * ä¸‹è½½å›¾ç‰‡æ•°æ®
   */
  private static async downloadImage(url: string): Promise<ArrayBuffer | null> {
    return new Promise((resolve, reject) => {
      const httpRequest = http.createHttp()

      // console.info('ImageCacheService', `ğŸ“¡ å‘èµ·HTTPè¯·æ±‚ - URL: ${url}`)

      httpRequest.request(url, {
        method: http.RequestMethod.GET,
        connectTimeout: ImageCacheService.TIMEOUT,
        readTimeout: ImageCacheService.TIMEOUT,
        header: {
          'User-Agent': 'Mozilla/5.0 (compatible; RSS Reader)',
          'Accept': 'image/*,*/*;q=0.8'
        }
      }, (error, data) => {
        httpRequest.destroy()

        if (error) {
          console.error('ImageCacheService', `âŒ HTTPè¯·æ±‚é”™è¯¯ - URL: ${url}, é”™è¯¯ç : ${error.code}, æ¶ˆæ¯: ${error.message}`)
          reject(error)
          return
        }

        if (data.responseCode === 200 && data.result) {
          const result = data.result as ArrayBuffer
          const sizeInMB = (result.byteLength / (1024 * 1024)).toFixed(2)
          const format = ImageCacheService.detectImageFormat(result)

          // console.info('ImageCacheService', `ğŸ“¥ ä¸‹è½½æˆåŠŸ - æ•°æ®å¤§å°: ${result.byteLength} bytes (${sizeInMB}MB), æ ¼å¼: ${format}`)
          // console.info('ImageCacheService', `ğŸ“Š HTTPå“åº” - çŠ¶æ€ç : ${data.responseCode}, Content-Type: ${data.header['content-type'] || 'unknown'}`)

          // æ£€æŸ¥æ–‡ä»¶å¤§å°
          if (result.byteLength > ImageCacheService.MAX_FILE_SIZE) {
            const maxSizeInMB = (ImageCacheService.MAX_FILE_SIZE / (1024 * 1024)).toFixed(2)
            console.error('ImageCacheService', `âŒ æ–‡ä»¶è¿‡å¤§ - ${sizeInMB}MB > ${maxSizeInMB}MB`)
            reject(new Error(`å›¾ç‰‡æ–‡ä»¶è¿‡å¤§: ${sizeInMB}MBï¼Œè¶…è¿‡é™åˆ¶ ${maxSizeInMB}MB`))
            return
          }

          resolve(result)
        } else {
          console.error('ImageCacheService', `âŒ HTTPè¯·æ±‚å¤±è´¥ - çŠ¶æ€ç : ${data.responseCode}`)
          reject(new Error(`HTTPé”™è¯¯: ${data.responseCode}`))
        }
      })
    })
  }

  /**
   * æ£€æµ‹å›¾ç‰‡æ ¼å¼
   */
  private static detectImageFormat(data: ArrayBuffer): string {
    if (data.byteLength < 8) {
      return 'unknown'
    }

    const view = new Uint8Array(data, 0, 8)

    // PNG: 89 50 4E 47 0D 0A 1A 0A
    if (view[0] === 0x89 && view[1] === 0x50 && view[2] === 0x4E && view[3] === 0x47) {
      return 'PNG'
    }

    // JPEG: FF D8 FF
    if (view[0] === 0xFF && view[1] === 0xD8 && view[2] === 0xFF) {
      return 'JPEG'
    }

    // GIF: 47 49 46 38 (GIF8)
    if (view[0] === 0x47 && view[1] === 0x49 && view[2] === 0x46 && view[3] === 0x38) {
      return 'GIF'
    }

    // WebP: RIFF...WEBP
    if (view[0] === 0x52 && view[1] === 0x49 && view[2] === 0x46 && view[3] === 0x46 &&
        data.byteLength >= 12) {
      const webpView = new Uint8Array(data, 8, 4)
      if (webpView[0] === 0x57 && webpView[1] === 0x45 && webpView[2] === 0x42 && webpView[3] === 0x50) {
        return 'WebP'
      }
    }

    return 'unknown'
  }

  /**
   * ç¡®ä¿ç›®å½•å­˜åœ¨
   */
  private static async ensureDirectoryExists(dirPath: string): Promise<boolean> {
    try {
      const stat = await fs.stat(dirPath)
      return stat.isDirectory()
    } catch (_) {
      try {
        await fs.mkdir(dirPath, true)
        return true
      } catch (mkdirError) {
        console.error('ImageCacheService', 'åˆ›å»ºç›®å½•å¤±è´¥:', mkdirError)
        return false
      }
    }
  }

  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜å›¾ç‰‡
   */
  static async cleanupOldImages(
    context: common.UIAbilityContext,
    maxAgeMs: number = 30 * 24 * 60 * 60 * 1000
  ): Promise<void> {
    try {
      const cacheDir = `${context.cacheDir}/rss_images`
      await ImageCacheService.traverseAndCleanup(cacheDir, maxAgeMs)
    } catch (error) {
      console.warn('ImageCacheService', 'æ¸…ç†è¿‡æœŸå›¾ç‰‡å¤±è´¥:', error)
    }
  }

  /**
   * é€’å½’éå†å¹¶æ¸…ç†è¿‡æœŸæ–‡ä»¶
   */
  private static async traverseAndCleanup(dir: string, maxAgeMs: number): Promise<void> {
    try {
      const files = await fs.listFile(dir) as Array<string>
      const now = Date.now()

      for (const fileName of files) {
        try {
          const filePath = `${dir}/${fileName}`
          const stat = await fs.stat(filePath)

          if (stat.isDirectory()) {
            // é€’å½’æ¸…ç†å­ç›®å½•
            await ImageCacheService.traverseAndCleanup(filePath, maxAgeMs)
            
            // æ£€æŸ¥ç›®å½•æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºåˆ™åˆ é™¤
            try {
              const subFiles = await fs.listFile(filePath) as Array<string>
              if (subFiles.length === 0) {
                await fs.rmdir(filePath)
                // console.info('ImageCacheService', `æ¸…ç†ç©ºç›®å½•: ${fileName}`)
              }
            } catch (_) { /* å¿½ç•¥åˆ é™¤ç›®å½•å¤±è´¥ */ }
          } else if (stat.isFile()) {
            // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦è¿‡æœŸ
            // OpenHarmony æ–‡ä»¶æ—¶é—´å¯èƒ½ä»¥ç§’ä¸ºå•ä½ï¼Œéœ€è¦è½¬æ¢ä¸ºæ¯«ç§’
            const fileMtimeMs = stat.mtime > 1000000000000 ? stat.mtime : stat.mtime * 1000
            const fileAge = now - fileMtimeMs
            const fileAgeHours = Math.round(fileAge / (1000 * 60 * 60))
            const maxAgeHours = Math.round(maxAgeMs / (1000 * 60 * 60))
            
            if (fileAge > maxAgeMs) {
              await fs.unlink(filePath)
              // console.info('ImageCacheService', `æ¸…ç†è¿‡æœŸå›¾ç‰‡: ${fileName} (å¹´é¾„: ${fileAgeHours}å°æ—¶ > é™åˆ¶: ${maxAgeHours}å°æ—¶)`)
            } else {
              // console.info('ImageCacheService', `ä¿ç•™å›¾ç‰‡: ${fileName} (å¹´é¾„: ${fileAgeHours}å°æ—¶ <= é™åˆ¶: ${maxAgeHours}å°æ—¶)`)
            }
          }
        } catch (error) {
          console.warn('ImageCacheService', `æ¸…ç†æ–‡ä»¶å¤±è´¥ ${fileName}:`, error)
        }
      }
    } catch (_) {
      // ç›®å½•ä¸å­˜åœ¨æˆ–è®¿é—®å¤±è´¥ï¼Œå¿½ç•¥
    }
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹ï¼ˆä¸ºäº†å…¼å®¹ç°æœ‰è°ƒç”¨ï¼‰
   */
  static getInstance(): ImageCacheService {
    return new ImageCacheService()
  }

  /**
   * å®ä¾‹æ–¹æ³•ï¼ˆä¸ºäº†å…¼å®¹ç°æœ‰è°ƒç”¨ï¼‰
   */
  async downloadAndCache(url: string, articleId?: string): Promise<string | undefined> {
    // è¿™ä¸ªæ–¹æ³•éœ€è¦ contextï¼Œä½†å®ä¾‹æ–¹æ³•æ— æ³•è·å–ï¼Œç›´æ¥è¿”å› undefined
    console.warn('ImageCacheService', 'è¯·ä½¿ç”¨é™æ€æ–¹æ³• ImageCacheService.downloadAndCache(url, articleId, context)')
    return undefined
  }

  async cleanupOldImages(): Promise<void> {
    console.warn('ImageCacheService', 'è¯·ä½¿ç”¨é™æ€æ–¹æ³• ImageCacheService.cleanupOldImages(context)')
  }

  /**
   * æ£€æŸ¥æŒ‡å®š URL æ˜¯å¦å·²ç¼“å­˜ï¼Œè¿”å›æœ¬åœ°è·¯å¾„ï¼Œä¸åšä»»ä½•ä¸‹è½½
   */
  static async getCachedPath(url: string, articleId: string, context: common.UIAbilityContext): Promise<string | null> {
    try {
      const cacheDir = `${context.cacheDir}/rss_images/${ImageCacheService.hash(articleId)}`
      const normalizedUrl = ImageCacheService.normalize(url)
      const fileName = ImageCacheService.hash(normalizedUrl)
      const filePath = `${cacheDir}/${fileName}`
      const stat = await fs.stat(filePath)
      if (stat.isFile()) {
        return filePath
      }
      return null
    } catch (_) {
      return null
    }
  }
} 